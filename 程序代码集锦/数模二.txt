#include <stdio.h>
#include <stdlib.h>
//仅适用于大于5*5的棋盘


int main()
{
   int a[101][101];
   int m,n,x,y,i=1,j=1;
   int p,q,e=1, sum=0;
   scanf ("%d%d",&m,&n);
     for(i=1;i<=m;i++){
      for(j=1;j<=n;j++){
       a[i][j]=0;//////////棋子都用0代替
       }
     }//构造棋盘

      for(i=1;i<=m;i++){
      for(j=1;j<=n;j++){
       printf(" %d",a[i][j]);
      }
       printf("\n");
     }//打印出棋盘

     ///////////////////////////////////
     ////////////////////////////
     ///////////////////////
     ///////////////
     /////////
     /////
     //


    /* for(x=1,y=1;x<=m&&y<=n;){  */

   /*   case 1*/
      for(x=1,e=1,y=1;x<=m&&y<=n;){
        for ( p=x,q=y;p<=m&&q<=n;){
        a[p][q]=1;
        p=p+2,q=q+1;

        sum++;
        }
        e=e*(-1);
       if(e==-1) x=x+1,y=y+3;//计算向右平移
       else x=x-1,y=y+2;
        }

       for(x=6,y=1;x<=m&&y<=n;){
         for ( p=x,q=y;p<=m&&q<=n;){
          a[p][q]=1;
          p=p+2,q=q+1;

         sum++;
         }
         x=x+5;//向下平移的个数
       }


       printf("\n\n\n\n%d\n",sum);
       for(i=1;i<=m;i++){
      for(j=1;j<=n;j++){
       printf(" %d",a[i][j]);
      }
       printf("\n");
     }



    //以上为第一种情况

  ///////////////////////////////////////
  /////////////////////////////////
  ///////////////////////////
  /////////////////////
  ///////////////
  /////////
  /////
  //

   /* case 2 */

      for(i=1;i<=m;i++){
      for(j=1;j<=n;j++){
       a[i][j]=0;//////////棋子都用0代替
       }
     }//重新构造棋盘
      sum=0;//重新确定最少子数
     for(x=1,e=1,y=2;x<=m&&y<=n;){
        for ( p=x,q=y;p<=m&&q<=n;){
        a[p][q]=1;//取掉的棋子用1代替
        p=p+2,q=q+1;

        sum++;
        }
        e=e*(-1);
       if(e==-1) x=x+1,y=y+3;//计算向右平移
       else x=x-1,y=y+2;
        }

       for(x=4,y=1;x<=m&&y<=n;){
         for ( p=x,q=y;p<=m&&q<=n;){
          a[p][q]=1;
          p=p+2,q=q+1;

         sum++;
         }
         x=x+5;//向下平移的个数
       }


       printf("\n\n\n\n%d\n",sum);
       for(i=1;i<=m;i++){
         for(j=1;j<=n;j++){
         printf(" %d",a[i][j]);
         }
       printf("\n");
       }



    //以上为第二种情况
  ///////////////////////////////////////
  /////////////////////////////////
  ///////////////////////////
  /////////////////////
  ///////////////
  /////////
  /////
  //

  /* case 3 */

       for(i=1;i<=m;i++){
        for(j=1;j<=n;j++){
        a[i][j]=0;//////////棋子都用0代替
        }
       }//重新构造棋盘
       sum=0;//重新确定最少子数
     for(x=1,e=1,y=3;x<=m&&y<=n;){
        for ( p=x,q=y;p<=m&&q<=n;){
        a[p][q]=1;//取掉的棋子用1代替
        p=p+2,q=q+1;

        sum++;
        }
        e=e*(-1);
       if(e==-1) x=x+1,y=y+3;//计算向右平移
       else x=x-1,y=y+2;
        }

       for(x=2,y=1;x<=m&&y<=n;){
         for ( p=x,q=y;p<=m&&q<=n;){
          a[p][q]=1;
          p=p+2,q=q+1;

         sum++;
         }
         x=x+5;//向下平移的个数
       }


       printf("\n\n\n\n%d\n",sum);
       for(i=1;i<=m;i++){
         for(j=1;j<=n;j++){
         printf(" %d",a[i][j]);
         }
       printf("\n");
       }

     //以上为第三种情况
  ///////////////////////////////////////
  /////////////////////////////////
  ///////////////////////////
  /////////////////////
  ///////////////
  /////////
  /////
  //

   /* case 4*/

       for(i=1;i<=m;i++){
        for(j=1;j<=n;j++){
        a[i][j]=0;//////////棋子都用0代替
        }
       }//重新构造棋盘
       sum=0;//重新确定最少子数

     for(x=1,e=1,y=4;x<=m&&y<=n;){
        for ( p=x,q=y;p<=m&&q<=n;){
        a[p][q]=1;//取掉的棋子用1代替
        p=p+2,q=q+1;

        sum++;
        }
        e=e*(-1);
       if(e==-1) x=x+1,y=y+3;//计算向右平移
       else x=x-1,y=y+2;
        }

       for(x=5,y=1;x<=m&&y<=n;){
         for ( p=x,q=y;p<=m&&q<=n;){
          a[p][q]=1;
          p=p+2,q=q+1;

         sum++;
         }
         x=x+5;
       }//向第一列下平移情况的子个数

        for ( p=2,q=2;p<=m&&q<=n;){
          a[p][q]=1;
          p=p+2,q=q+1;

         sum++;
         }//第四五种情况特有的漏洞

       printf("\n\n\n\n%d\n",sum);
       for(i=1;i<=m;i++){
         for(j=1;j<=n;j++){
         printf(" %d",a[i][j]);
         }
       printf("\n");
       }

     //以上为第四种情况
  ///////////////////////////////////////
  /////////////////////////////////
  ///////////////////////////
  /////////////////////
  ///////////////
  /////////
  /////
  //

  /* case 5  */

       for(i=1;i<=m;i++){
        for(j=1;j<=n;j++){
        a[i][j]=0;//////////棋子都用0代替
        }
       }//重新构造棋盘
       sum=0;//重新确定最少子数

     for(x=1,e=1,y=5;x<=m&&y<=n;){
        for ( p=x,q=y;p<=m&&q<=n;){
        a[p][q]=1;//取掉的棋子用1代替
        p=p+2,q=q+1;

        sum++;
        }
        e=e*(-1);
       if(e==-1) x=x+1,y=y+3;
       else x=x-1,y=y+2;
        }//计算向右平移//

       for(x=3,y=1;x<=m&&y<=n;){
         for ( p=x,q=y;p<=m&&q<=n;){
          a[p][q]=1;
          p=p+2,q=q+1;

         sum++;
         }
         x=x+5;
       }//向第一列平移情况的子个数

        for ( p=2,q=3;p<=m&&q<=n;){
          a[p][q]=1;
          p=p+2,q=q+1;

         sum++;
         }//第四五种情况特有的漏洞

       printf("\n\n\n\n%d\n",sum);
       for(i=1;i<=m;i++){
         for(j=1;j<=n;j++){
         printf(" %d",a[i][j]);
         }
       printf("\n");
       }


    return 0;
}
